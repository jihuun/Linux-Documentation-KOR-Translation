1: A GUIDE TO THE KERNEL DEVELOPMENT PROCESS
1: 커널 개발 프로세스 가이드.

The purpose of this document is to help developers (and their managers)
work with the development community with a minimum of frustration.  It is
an attempt to document how this community works in a way which is
accessible to those who are not intimately familiar with Linux kernel
development (or, indeed, free software development in general).  While
there is some technical material here, this is very much a process-oriented
discussion which does not require a deep knowledge of kernel programming to
understand.
##이 문서의 목적은 좌절하지 않고 커널 커뮤니티에서 활동할 수 있도록 개발자(또는
관리자)를 돕는 데에 있다.  리눅스 커널 개발에 익숙하지 않는 사람들도 커뮤니티가
어떻게 돌아가는지 이해하게 될것이다.  약간의 기술적인 내용을 포함하고 있지만,
개발 프로세스에 대해 주로 다루는 문서 이므로 커널 프로그래밍에 대한 깊은 지식이
없어도 이 문서를 이해하는 데에는 문제가 없다.

1.1: EXECUTIVE SUMMARY
1.1: 요약

The rest of this section covers the scope of the kernel development process
and the kinds of frustrations that developers and their employers can
encounter there.  There are a great many reasons why kernel code should be
merged into the official ("mainline") kernel, including automatic
availability to users, community support in many forms, and the ability to
influence the direction of kernel development.  Code contributed to the
Linux kernel must be made available under a GPL-compatible license.
이 섹션의 나머지 부분은 커널 개발 프로세스와 개발자와 그들의 고용주가 직면할 수
있는 문제들을 다룬다. 유저에게 쉽게 제공되며, 커뮤니티로부터 여러 가지 형태의
지원을 받을 수 있고, 커널 개발 방향에 영향을 줄 수 있다는 점 등을 포함해서
코드가 공식(메인라인) 커널에 반영되어야 할 좋은 이유가 많이 있다.  리눅스
커널에 기여할 코드는 GPL라이센스에 호환되어 사용할 수 있도록 만들어져야 한다.

Section 2 introduces the development process, the kernel release cycle, and
the mechanics of the merge window.  The various phases in the patch
development, review, and merging cycle are covered.  There is some
discussion of tools and mailing lists.  Developers wanting to get started
with kernel development are encouraged to track down and fix bugs as an
initial exercise.
섹션 2 에서는 개발 프로세스, 커널의 릴리즈 주기, 그리고 merge window 매커니즘에
대해 소개한다.  패치 작성, 리뷰, 패치 반영 주기 등을 다양하게 다룰 것이다.
그리고 일부 툴과 메일링 리스트에 대해서도 다룰 것이다. 커널 개발을 시작하려고
하는 개발자들은 버그를 찾아 수정하는 것으로 시작하는 것이 좋다.

Section 3 covers early-stage project planning, with an emphasis on
involving the development community as soon as possible.
섹션 3 에서는 가능한 빨리 개발 커뮤니티에 참여 하는것을 주안점으로 프로젝트
초기 단계에서 계획을 세우는 법을 다룬다.

Section 4 is about the coding process; several pitfalls which have been
encountered by other developers are discussed.  Some requirements for
patches are covered, and there is an introduction to some of the tools
which can help to ensure that kernel patches are correct.
섹션 4 는 코딩 프로세스에 대한 내용이다.  다른 개발자들의 논의를 통해 알려진
몇몇의 위험에 대해서도 다룬다.  패치를 할때 지켜야 할 몇가지 요구사항들을
다루며, 올바른 커널 패치 인지 확인할때 도움이 되는 툴도 소개한다.

Section 5 talks about the process of posting patches for review.  To be
taken seriously by the development community, patches must be properly
formatted and described, and they must be sent to the right place.
Following the advice in this section should help to ensure the best
possible reception for your work.
섹션 5 는 패치를 포스트하고 리뷰를 받는 프로세스에 대해 논의 한다.  패치가
커뮤니티에서 진지하게 받아들여지려면, 패치는 반드시 적절한 형식을 지키고 설명도
포함되어야 한다.  그리고 패치는 정확한 장소로 전달 되어야 한다.  이 섹션의
가이드를 따른다면 패치가 받아들여질 확률은 높아진다.

Section 6 covers what happens after posting patches; the job is far from
done at that point.  Working with reviewers is a crucial part of the
development process; this section offers a number of tips on how to avoid
problems at this important stage.  Developers are cautioned against
assuming that the job is done when a patch is merged into the mainline.
섹션 6 에서는 패치를 포스팅한 이후에 어떻게 되는지에 대해 논의 한다.  패치를
등록했다고 다 끝난 것이 아니다.  리뷰를 받는 것은 개발 프로세스에서 매우 중요한
절차이고 이 과정에서 문제가 발생하는것을 줄일 수 있는 팁을 제공한다.  개발자는
패치가 메인라인에 반영 되었다고 모든일이 끝난것으로 단정 짓지 않도록 주의해야
한다.

Section 7 introduces a couple of "advanced" topics: managing patches with
git and reviewing patches posted by others.
섹션 7 에서는 git 으로 패치를 관리하고 다른사람이 등록한 패치를 리뷰하는 방법에
대해 논의 한다.

Section 8 concludes the document with pointers to sources for more
information on kernel development.
섹션 8 에서는 커널 개발에 관련된 더 많은 정보를 위해 ##소스코드 레벨에서 문서를
결론 짓는다.


1.2: WHAT THIS DOCUMENT IS ABOUT
1.2: 이 문서가 말하려는 것

The Linux kernel, at over 8 million lines of code and well over 1000
contributors to each release, is one of the largest and most active free
software projects in existence.  Since its humble beginning in 1991, this
kernel has evolved into a best-of-breed operating system component which
runs on pocket-sized digital music players, desktop PCs, the largest
supercomputers in existence, and all types of systems in between.  It is a
robust, efficient, and scalable solution for almost any situation.
리눅스 커널은 800만줄 이상의 코드로 구현되어 있으며 각 릴리즈 마다 1000명
이상의 개발자들이 컨트리뷰션 한다.  이것은 존재하는 어떠한 프로젝트 보다 규모가
크고 가장 활발하게 진행 되고 있는 자유 소프트웨어(오픈 소스) 프로젝트 이다.
1991년의 작은 시작 이후 성장을 거듭하면서 현재는 소형 mp3 플레이어, 데스크탑
PC, 현존하는 가장 거대한 슈퍼컴퓨터등 기타 모든 시스템에서 사용되는 가장 뛰어난
운영체제가 되었다.  리눅스는 어떤 상황에서도 가장 탄탄하고 효율적이고 확장성이
좋은 솔루션 이다.

With the growth of Linux has come an increase in the number of developers
(and companies) wishing to participate in its development.  Hardware
vendors want to ensure that Linux supports their products well, making
those products attractive to Linux users.  Embedded systems vendors, who
use Linux as a component in an integrated product, want Linux to be as
capable and well-suited to the task at hand as possible.  Distributors and
other software vendors who base their products on Linux have a clear
interest in the capabilities, performance, and reliability of the Linux
kernel.  And end users, too, will often wish to change Linux to make it
better suit their needs
리눅스의 성장으로 인하여 리눅스 개발에 참여 하려고 하는 개발자(혹은 회사) 수가
많이 증가 하였다.  하드웨어 제조사는 리눅스가 자사 제품을 잘 지원해서 자사
제품들이 리눅스 유저들에게 어필하기를 원한다.  제품에 리눅스가 사용되는
임베디드 시스템 업체는 리눅스가 보다 쉽게 포팅 되기를 원한다.  리눅스 기반의
소프트웨어의 벤더나 판매자는 가능한한 성능과 신뢰성에 관심을 갖고 있다.  그리고
최종 사용자는 그들의 필요에 따라서 리눅스가 더 좋게 변화 하길 원한다.

One of the most compelling features of Linux is that it is accessible to
these developers; anybody with the requisite skills can improve Linux and
influence the direction of its development.  Proprietary products cannot
offer this kind of openness, which is a characteristic of the free software
process.  But, if anything, the kernel is even more open than most other
free software projects.  A typical three-month kernel development cycle can
involve over 1000 developers working for more than 100 different companies
(or for no company at all).
리눅스의 가장 강력한 특징중 하나는 개발자들이 접근 하기 쉽다는 점이다.  누구나
리눅스를 개선시킬 수 있으며 개발 방향에 영향을 줄 수 있다.  상업적인 제품에서는
이런 자유 소프트웨어의 특징인 개방성을 볼 수 없다.  특히 리눅스 커널은 대부분의
자유 소프트웨어 프로젝트 보다 개방적이다.  일반적인 3개월의 커널 개발 주기동안
1000명 이상의 개발자, 100개 이상의 회사가 참여한다.

Working with the kernel development community is not especially hard.  But,
that notwithstanding, many potential contributors have experienced
difficulties when trying to do kernel work.  The kernel community has
evolved its own distinct ways of operating which allow it to function
smoothly (and produce a high-quality product) in an environment where
thousands of lines of code are being changed every day.  So it is not
surprising that Linux kernel development process differs greatly from
proprietary development methods.
리눅스 커널 커뮤니티와 작업하는것은 그렇게 어렵지 않음에도 불구하고 많은 잠재적
컨트리뷰터들이 커널 개발에 어려움을 겪고 있다. 커널 커뮤니티는 매일 수천 줄의
코드가 수정되는 환경 속에서도 뛰어난 코드를 유지하는 뚜렷한 고유의 운영 방식을
발전시켜 왔다.  따라서 리눅스 커널 개발 프로세스와 상업적인 소프트웨어의 개발
방법론에 큰 차이가 있다는것은 그리 놀라운 일이 아니다.

The kernel's development process may come across as strange and
intimidating to new developers, but there are good reasons and solid
experience behind it.  A developer who does not understand the kernel
community's ways (or, worse, who tries to flout or circumvent them) will
have a frustrating experience in store.  The development community, while
being helpful to those who are trying to learn, has little time for those
who will not listen or who do not care about the development process.
커널 개발 프로세스가 새로운 개발자들에게는 다소 어렵고 두렵게 느껴질 수도
있지만 그 이면에는 탄탄한 경험과 분명한 이유가 있다. 커널 개발 프로세스를
이해하지 못한 개발자는 ##좌절스러운 경험을 하게 될 것다. 이 커뮤니티는 ##들으려
하지않고 개발 프로세스를 전혀 신경쓰지 않는 개발자에게 많은 시간을 주지 않는
반면, 배우고자 하는 개발자에게 이 커뮤니티는 많은 도움이 될 것이다.

It is hoped that those who read this document will be able to avoid that
frustrating experience.  There is a lot of material here, but the effort
involved in reading it will be repaid in short order.  The development
community is always in need of developers who will help to make the kernel
better; the following text should help you - or those who work for you -
join our community.
이글을 읽음 으로써 커널 개발의 ##두려움이 사라지기를 희망 한다. 이 문서는 양이
방대해 읽기 힘들겠지만 ##다 읽고 나면 노력은 곧 보답으로 돌아 올 것이다. 리눅스
커뮤니티는 커널을 발전시켜줄 개발자들이 항상 필요하다. 이어질 내용들이 커뮤니티
참여에 도움을 줄 것이다. ##우리 커뮤니티와 함께 하자.


1.3: CREDITS
1.3: 감사의 말

This document was written by Jonathan Corbet, corbet@lwn.net.  It has been
improved by comments from Johannes Berg, James Berry, Alex Chiang, Roland
Dreier, Randy Dunlap, Jake Edge, Jiri Kosina, Matt Mackall, Arthur Marsh,
Amanda McPherson, Andrew Morton, Andrew Price, Tsugikazu Shibata, and
Jochen Voß.

This work was supported by the Linux Foundation; thanks especially to
Amanda McPherson, who saw the value of this effort and made it all happen.

이 문서는 Jonathan Corbet (corbet@lwn.net)에 의해 작성 되었다. 또한 다음의
사람들을 통해 문서가 더욱 다듬어 졌다.  Johannes Berg, James Berry, Alex
Chiang, Roland Dreier, Randy Dunlap, Jake Edge, Jiri Kosina, Matt Mackall,
Arthur Marsh, Amanda McPherson, Andrew Morton, Andrew Price, Tsugikazu Shibata,
and Jochen Voß.

이 작업은 리눅스 재단을 통해 지원 받고 있다. 특별히 Amanda McPherson에게
감사한다.  그는 이 일의 가치를 알아 봤으며 이 모든것을 가능하게 만들어 주었다.

1.4: THE IMPORTANCE OF GETTING CODE INTO THE MAINLINE
1.4: 메인라인에 코드를 반영하는것의 중요성

Some companies and developers occasionally wonder why they should bother
learning how to work with the kernel community and get their code into the
mainline kernel (the "mainline" being the kernel maintained by Linus
Torvalds and used as a base by Linux distributors).  In the short term,
contributing code can look like an avoidable expense; it seems easier to
just keep the code separate and support users directly.  The truth of the
matter is that keeping code separate ("out of tree") is a false economy.
일부 업체와 개발자들은 커널 커뮤니티와 작업하고 메인라인 커널(리누스 토발즈에
의해 관리되며 리눅스 디스트리뷰터에 의해 베이스로 사용되는)에 자신들의 코드를
넣는 일을 귀찮다고 생각한다. 단기적으로는 코드를 기여하는 것은 불필요한
비용으로 생각 할 수 있다. 그냥 별도의 코드를 유지하고 사용자를 직접 지원하는
것이 쉬워 보이기 때문이다.  하지만 사실은 메인라인에 반영하지 않고 독립적으로
코드(out of tree)를 유지하는 것은 장기적으로 경제적이지 않다.

As a way of illustrating the costs of out-of-tree code, here are a few
relevant aspects of the kernel development process; most of these will be
discussed in greater detail later in this document.  Consider:
독립적인 코드(out of tree)를 유지 하는것의 비용을 설명하기 위해 몇 가지 커널
개발 프로세스의 중요한 측면을 여기서 소개한다; 상세한 사항은 이 문서 나중에 더
상세히 논의 될 것이다.

- Code which has been merged into the mainline kernel is available to all
  Linux users.  It will automatically be present on all distributions which
  enable it.  There is no need for driver disks, downloads, or the hassles
  of supporting multiple versions of multiple distributions; it all just
  works, for the developer and for the user.  Incorporation into the
  mainline solves a large number of distribution and support problems.
- 메인라인 커널에 통합 된 코드는 모든 리눅스 사용자가 사용할 수 있다.  그
  코드를 사용하기로 설정한 모든 배포판에 자동으로 제공될 것이다.  그것은
  드라이버 디스크, 다운로드, 또는 다수의 버전을 지원하는 번거로움이 필요하지
  않다.  모든것이 사용자와 개발자를 위해 바로 동작한다.  메인라인으로의 통합은
  다양한 배포 및 지원 관련 문제를 해결 할 수있다.

- While kernel developers strive to maintain a stable interface to user
  space, the internal kernel API is in constant flux.  The lack of a stable
  internal interface is a deliberate design decision; it allows fundamental
  improvements to be made at any time and results in higher-quality code.
  But one result of that policy is that any out-of-tree code requires
  constant upkeep if it is to work with new kernels.  Maintaining
  out-of-tree code requires significant amounts of work just to keep that
  code working.
  커널 개발자는 유저공간에 안정적인 인터페이스를 유지하기 위해 노력하지만 내부
  커널 API는 유동적이다. ##안정적인 내부 인터페이스가 부족한 것은 신중논의 끝에
  결정된 설계다.  이는 근본적인 문제를 언제든 개선 할 수 있으며 결과적으로
  고품질의 코드를 만든다.  ##그러나 이런 정책의 결과로 독립적인
  코드(out-of-tree)의 지속적인 유지보수 비용이 필요하게 되었다. 독립 코드는
  코드를 작동하도록 유지보수 하는데만 해도 상당한 양의 비용이 필요하다.

  Code which is in the mainline, instead, does not require this work as the
  result of a simple rule requiring any developer who makes an API change
  to also fix any code that breaks as the result of that change.  So code
  which has been merged into the mainline has significantly lower
  maintenance costs.
  ##대신에 메인라인에 있는 코드는 API를 수정하는 모든 개발자가 변화의 결과로
  발생하는 모든 문제 코드를 해결해야 한다는 간단한 규칙 덕분에 위와 같은 작업이
  필요하지 않다.  그래서 메인 라인에 병합 된 코드는 상당히 낮은 유지 보수
  비용이 드는것이다.

- Beyond that, code which is in the kernel will often be improved by other
  developers.  Surprising results can come from empowering your user
  community and customers to improve your product.
- 그뿐 아니라 메인라인에 있는 코드는 종종 다른 개발자의 의해 향상 될 것이다.
  사용자 커뮤니티와 제품을 개선하고자 하는 고객에 의해 놀라운 결과가 나올 수
  있다.

- Kernel code is subjected to review, both before and after merging into
  the mainline.  No matter how strong the original developer's skills are,
  this review process invariably finds ways in which the code can be
  improved.  Often review finds severe bugs and security problems.  This is
  especially true for code which has been developed in a closed
  environment; such code benefits strongly from review by outside
  developers.  Out-of-tree code is lower-quality code.
- 커널 코드는 메인라인에 반영하기 이전과 이후 모두 리뷰를 받아야 한다.
  개발자의 실력이 뛰어난 것과는 관계없이 리뷰 프로세스는 코드 개선을 위해
  반드시 필요한 방법 이다.  리뷰과정을 통해 종종 버그와 보안문제가 발견 되기도
  한다.  특별히 이것은 폐쇠된 개발 환경에서 코드를 개발하기 위한 방법이기도
  하다.  이런 코드가 외부의 개발자를 통해 리뷰받는 다면 많은 도움이 될 것이다.
  ##따라서 메인라인에 반영하지 않고 독립적으로 운영되는 커널코드(Out-of-tree)의
  품질은 좋을 수가 없다.

- Participation in the development process is your way to influence the
  direction of kernel development.  Users who complain from the sidelines
  are heard, but active developers have a stronger voice - and the ability
  to implement changes which make the kernel work better for their needs.
  ##개발 프로세스에 참여하는것은 커널 개발에 직접적으로 참여하는 방법이다.
  ##사이드 라인에서 불평하는 유저는 많지만 실제 활동하는 개발자는 힘있는
  목소리와 그들의 원하는 대로 커널을 개선 시키는 능력을 가지고 있다.

- When code is maintained separately, the possibility that a third party
  will contribute a different implementation of a similar feature always
  exists.  Should that happen, getting your code merged will become much
  harder - to the point of impossibility.  Then you will be faced with the
  unpleasant alternatives of either (1) maintaining a nonstandard feature
  out of tree indefinitely, or (2) abandoning your code and migrating your
  users over to the in-tree version.
- 코드가 별도로 관리되는 경우, 서드파티가 이미 존재하는 유사한 기능 구현을 반복
  할 가능성이 항상 존재한다. 그렇게 되면 그 코드를 머지하는것은 불가능에 가깝게
  힘들어질 것이다. 이 경우 두가지 대안이 있다.
  (1) 그 비공식 기능을 영원히 out-of-tree 코드로 유지
  ##(2) 코드를 포기하고 사용자를 in-tree 버전으로 이동 시킨다.

- Contribution of code is the fundamental action which makes the whole
  process work.  By contributing your code you can add new functionality to
  the kernel and provide capabilities and examples which are of use to
  other kernel developers.  If you have developed code for Linux (or are
  thinking about doing so), you clearly have an interest in the continued
  success of this platform; contributing code is one of the best ways to
  help ensure that success.
  코드를 컨트리뷰션 하는것은 전체 프로세스를 작동시키는 근본적인 행위이다.
  코드를 컨트리뷰트함으로써 커널에 새로운 기능을 추가하고 다른 커널
  개발자들에게 쓸모있는 기능과 예제를 제공 할 수 있다.  Linux용 코드를
  개발한(또는 앞으로 개발할) 경우, 당신은 명확하게 이 플랫폼의 지속적인 성공에
  관심을 있을것이고 코드를 기여하는 것은 그 성공을 보장하는 가장 좋은 방법 중
  하나이다.

All of the reasoning above applies to any out-of-tree kernel code,
including code which is distributed in proprietary, binary-only form.
There are, however, additional factors which should be taken into account
before considering any sort of binary-only kernel code distribution.  These
include:
##위의 모든 논리는 상업적이거나 바이너리로 배포되는 코드를 포함한 모든
out-of-tree 커널 코드에 적용된다.  ##그러나 바이너리로 배포하기 전에 고려되어야
할 부가 요소가 있다. 이들은 다음을 포함한다.

- The legal issues around the distribution of proprietary kernel modules
  are cloudy at best; quite a few kernel copyright holders believe that
  most binary-only modules are derived products of the kernel and that, as
  a result, their distribution is a violation of the GNU General Public
  license (about which more will be said below).  Your author is not a
  lawyer, and nothing in this document can possibly be considered to be
  legal advice.  The true legal status of closed-source modules can only be
  determined by the courts.  But the uncertainty which haunts those modules
  is there regardless.
- ##상업적인 커널 모듈의 배포는 항상 법적으로 문제의 소지가 있다.  ##대부분의
  커널 저작권자는 바이너리 모듈이 커널의 파생 코드이기 때문에 바이너리 배포가
  (아래에서 다룰) GPL 라이센스의 위반이라고 생각한다.  ##저자는 변호사가 아니며
  이 문서는 법적 조언으로 간주 될 수 없다.  ##closed-소스 모듈의 법적 상태는
  법원에 의해 결정될 것이다.  ##하지만 그 모듈이 법적으로 문제의 소지가
  있는것은 확실하다.

- Binary modules greatly increase the difficulty of debugging kernel
  problems, to the point that most kernel developers will not even try.  So
  the distribution of binary-only modules will make it harder for your
  users to get support from the community.
- 바이너리 모듈은 대부분의 커널 개발자가 디버깅은 시도조차하지 않는다는 점에서
  커널 디버깅을 어렵게 한다. 그래서 바이너리 모듈로만 제공되는 배포판은
  사용자가 커뮤니티의 지원을 받기 어렵게 만들 것이다.

- Support is also harder for distributors of binary-only modules, who must
  provide a version of the module for every distribution and every kernel
  version they wish to support.  Dozens of builds of a single module can
  be required to provide reasonably comprehensive coverage, and your users
  will have to upgrade your module separately every time they upgrade their
  kernel.
- ##바이너리만 제공되는 모듈의 배포자도 사용자를 지원하려면 모든 배포와 그들이
  지원하고자하는 모든 커널 버전에 대한 모듈의 버전을 제공해야하기 때문에
  어렵다. 하나의 모듈을 수십번 빌드해야 포괄적으로 사용자를 지원할 수 있고,
  사용자도 커널을 업그레이드 할 때마다 모듈을 업그레이드해야한다.

- Everything that was said above about code review applies doubly to
  closed-source code.  Since this code is not available at all, it cannot
  have been reviewed by the community and will, beyond doubt, have serious
  problems.
- ##closed-소스 코드에 위에 말한 모든 내용이 중복 적용된다.  코드는 커뮤니티에
  의해 검토되지 않게 되며, 의심 할 여지없이 심각한 문제가된다.

Makers of embedded systems, in particular, may be tempted to disregard much
of what has been said in this section in the belief that they are shipping
a self-contained product which uses a frozen kernel version and requires no
more development after its release.  This argument misses the value of
widespread code review and the value of allowing your users to add
capabilities to your product.  But these products, too, have a limited
commercial life, after which a new version must be released.  At that
point, vendors whose code is in the mainline and well maintained will be
much better positioned to get the new product ready for market quickly.
특히 임베디드 시스템 업체들은 제품에 개발이 중지된(frozen) 커널 버전을 사용하면
출시후 더 이상의 개발이 필요하지 않다고 생각 하면서 이 섹션에서 언급된 내용을
무시하고 싶을 수 있다. 이런 생각은 대량의 코드리뷰의 가치와 자사의 제품에
사용자가 직접 기능을 추가 할 수 있다는 장점을 놓치는 것이다. 그러나 이런 제품
역시 새 버전이 출시되어야하는 시점까지 어느정도 제한된 수명을 가지고있다. 그
시점에서는, 메인라인 코드로 잘 유지된 제품이 훨씬 더 빨리 시장에 새 제품을
내놓을 수 있을 것이다.


1.5: LICENSING
1.5: 라이선스

Code is contributed to the Linux kernel under a number of licenses, but all
code must be compatible with version 2 of the GNU General Public License
(GPLv2), which is the license covering the kernel distribution as a whole.
In practice, that means that all code contributions are covered either by
GPLv2 (with, optionally, language allowing distribution under later
versions of the GPL) or the three-clause BSD license.  Any contributions
which are not covered by a compatible license will not be accepted into the
kernel.
코드는 다수의 라이선스 아래 리눅스 커널에 기여하는데, 특히 모든 코드는 전체
커널 배포를 관장하는 version 2 of the GNU General Public License (GPLv2)와
호환되어야 한다. 실제로, 모든 코드 컨트리뷰션이 GPLv2(선택적으로, GPL의 차기
버전까지 포함) 또는 BSD 라이선스(3 조항 버전) 에 의해 다루어진다는 것을
의미하며, 위 라이선스를 지키지 않은 코드는 커널에 포함되지 않는다.

Copyright assignments are not required (or requested) for code contributed
to the kernel.  All code merged into the mainline kernel retains its
original ownership; as a result, the kernel now has thousands of owners.
커널에 기여하는 코드를 위한 저작권 할당은 따로 필요없다.  메인 라인 커널이
가지고 있는 저작권이 자동으로 적용되기 때문에 자동으로 오픈소스가 된다.

One implication of this ownership structure is that any attempt to change
the licensing of the kernel is doomed to almost certain failure.  There are
few practical scenarios where the agreement of all copyright holders could
be obtained (or their code removed from the kernel).  So, in particular,
there is no prospect of a migration to version 3 of the GPL in the
foreseeable future.
이런 소유 구조는 리눅스의 라이선스를 변경하려는 시도는 불가능함을 의미한다.
모든 저작권 소유자의 동의를 얻는 등 (또는 코드가 커널에서 제거) 몇 가지
실제적인 시나리오가 있고, 그래서 가까운 미래에 GPL 버전 3으로 마이그레이션은
전혀 전망이 없다.

It is imperative that all code contributed to the kernel be legitimately
free software.  For that reason, code from anonymous (or pseudonymous)
contributors will not be accepted.  All contributors are required to "sign
off" on their code, stating that the code can be distributed with the
kernel under the GPL.  Code which has not been licensed as free software by
its owner, or which risks creating copyright-related problems for the
kernel (such as code which derives from reverse-engineering efforts lacking
proper safeguards) cannot be contributed.
모든 코드가 커널에 합법적인 자유 소프트웨어(free software)로 기여하는 것이
필수적이다.  이러한 이유로, 익명 (또는 가명) 참여자의 코드는 허용되지 않는다.
모든 참여자는 코드가 GPL 아래 커널과 함께 배포 될 수 있다고 자신의 코드에
서명(sign-off) 해야 한다.  소유자에 의해 free software로 허가되지 않았거나 (ex.
적절한 보호장치없이 리버스 엔지니어링으로 파생 된 코드로) 커널에 대한 저작권
관련 문제를 만들 위험이있는 코드는 커널에 기여 할 수 없다.

Questions about copyright-related issues are common on Linux development
mailing lists.  Such questions will normally receive no shortage of
answers, but one should bear in mind that the people answering those
questions are not lawyers and cannot provide legal advice.  If you have
legal questions relating to Linux source code, there is no substitute for
talking with a lawyer who understands this field.  Relying on answers
obtained on technical mailing lists is a risky affair.
저작권 관련 문제에 대한 질문은 리눅스 개발 메일링리스트에 빈번히 올라온다.
이러한 질문은 보통의 많은 답변을 받을 수 있지만, 그 답변을 한 사람들이 변호사가
아니며 법률적인 자문을 제공 할 수 없음을 명심해야한다.  리눅스 소스코드에 관한
법적 문제가 있는 경우, 이 분야를 이해하는 변호사와 이야기 하는 것이 최선이며,
메일링리스트에서 얻은 답변에 의존하는 것은 위험할 수 있다.
