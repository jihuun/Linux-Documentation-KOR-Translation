7: ADVANCED TOPICS

At this point, hopefully, you have a handle on how the development process
works.  There is still more to learn, however!  This section will cover a
number of topics which can be helpful for developers wanting to become a
regular part of the Linux kernel development process.
이제 당신은 리눅스 개발 프로세스를 어떻게 진행하는지 알고 그것을 다룰수 있게
되었을 것이다.  그러나 아직 알아야 할것이 더 남아있다. 이 섹션에서는 리눅스 커널
개발 프로세스의 일부분이 되고자 하는 개발자들을 위해 다양한 주제를 다룬다.

7.1: MANAGING PATCHES WITH GIT
7.1: GIT을 이용한 패치 관리

The use of distributed version control for the kernel began in early 2002,
when Linus first started playing with the proprietary BitKeeper
application.  While BitKeeper was controversial, the approach to software
version management it embodied most certainly was not.  Distributed version
control enabled an immediate acceleration of the kernel development
project.  In current times, there are several free alternatives to
BitKeeper.  For better or for worse, the kernel project has settled on git
as its tool of choice.
리눅스 커널은 2002년초 부터 버전관리 툴을 이용하기 시작했고,  리누스 토발즈는
상용 응용프로그램인 BitKeeper를 사용했다.  ##BitKeeper는 논란이 있었지만,
버전관리 소프트웨어에 대한 접근embodied most certainly was not.  ##배포된 버전
관리는 커널 개발 프로젝트가 즉시 착수되도록 했다.  현재는 BitKeeper를 대체할 수
있는 몇몇의 무료 툴이 존재한다. 좋든 싫든, 커널은 git을 선택했다.

Managing patches with git can make life much easier for the developer,
especially as the volume of those patches grows.  Git also has its rough
edges and poses certain hazards; it is a young and powerful tool which is
still being civilized by its developers.  This document will not attempt to
teach the reader how to use git; that would be sufficient material for a
long document in its own right.  Instead, the focus here will be on how git
fits into the kernel development process in particular.  Developers who
wish to come up to speed with git will find more information at:
특히 패치의 양이 방대해짐에 따라 git을 이용해 패치를 관리하는것이 개발자에게 더
나은 삶을 줄 수 있다.  ##Git도 분명 단점이 있도 위험이 있다. 그리고 이것은
여전히 문명화된 곳에서 개발자들이 사용하는 강력한 툴이다.  이 문서는 git을
어떻게 사용하는지 알려주지는 않는다. 그걸 설명하기 위해서 그 자체로 별개의
충분한 문서가 필요하다.  그래서 대신, 특히 어떻게 git이 커널 개발 프로세스에
적합한지에 대해 초점을 맞춘다.  보다 빨리 git 을 사용하고자 한다면 아래에서 더
많은 정보를 얻을 수 있다.

	http://git-scm.com/

	http://www.kernel.org/pub/software/scm/git/docs/user-manual.html

and on various tutorials found on the web.
그리고 웹에서 보다 다양한 튜토리얼들을 찾을 수 있을 것이다.

The first order of business is to read the above sites and get a solid
understanding of how git works before trying to use it to make patches
available to others.  A git-using developer should be able to obtain a copy
of the mainline repository, explore the revision history, commit changes to
the tree, use branches, etc.  An understanding of git's tools for the
rewriting of history (such as rebase) is also useful.  Git comes with its
own terminology and concepts; a new user of git should know about refs,
remote branches, the index, fast-forward merges, pushes and pulls, detached
heads, etc.  It can all be a little intimidating at the outset, but the
concepts are not that hard to grasp with a bit of study.
가장 먼저 해야할 것은git을 이용해 다른 사람들에게 패치를 만들어 전달하기 전에
위의 사이트를 읽고 git이 어떻게 동작하는지 충분히 이해하는 것이다.  git을
사용하는 개발자는 다음을 할 수 있어야 한다; 메인라인 저장소를 복사해 올수 있고,
revision 히스토리를 탐색 할 수 있으며, 커밋 수정사항, 그리고 브랜치를 사용할 수
있다. git을 이용해 rebase같이 히스토리를 재 수정하는것도 유용하다.  git은 여러
용어를 가지고 있는데, 다음의 용어들을 숙지해야한다; refs, 원격 브랜치(remote
branches), index, fast-forward merges, push, pull, detached heads, 등. 이것들은
처음에 진입장벽이 다소 높을 수 있으나, 조금만 공부하면 내용을 파악하는데 어렵지
않은 컨셉이다.

Using git to generate patches for submission by email can be a good
exercise while coming up to speed.
git을 사용해 패치를 만들어 이메일을 통해 제출해보는것도 빠르게 익히기 위한 좋은
연습이 될 수 있다.

When you are ready to start putting up git trees for others to look at, you
will, of course, need a server that can be pulled from.  Setting up such a
server with git-daemon is relatively straightforward if you have a system
which is accessible to the Internet.  Otherwise, free, public hosting sites
(Github, for example) are starting to appear on the net.  Established
developers can get an account on kernel.org, but those are not easy to come
by; see http://kernel.org/faq/ for more information.
다른사람이 git 트리를 볼수 있게 준비가 되었다면, 당연히 pull될 수 있도록 서버가
필요할 것이다.  인터넷에 접속가능한 시스템을 가지고 있다면 git-daemon을 이용해
서버를 구축하는것은 비교적 간단한 방법이다.  그렇지 않다면 무료 공개 호스팅
사이트를(예를 들어 github) 이용하는 ##것도 좋다.  ##Established developers는
kernel.org에서 계정을 얻을 수 있다. 그러나 이방법은 쉽게 접근할수 있는 방법은
아니다.  http://kernel.org/faq/ 에서 더 많은 정보를 확인할 수 있다.

The normal git workflow involves the use of a lot of branches.  Each line
of development can be separated into a separate "topic branch" and
maintained independently.  Branches in git are cheap, there is no reason to
not make free use of them.  And, in any case, you should not do your
development in any branch which you intend to ask others to pull from.
Publicly-available branches should be created with care; merge in patches
from development branches when they are in complete form and ready to go -
not before.
일반적인 git 작업흐름(workflow)은 많은 수의 브랜치를 이용한다.  각각의 개발은
각각 독립된 주제의 브랜치에서 관리된다. git에서 브랜치를 이용하는것은 매우
간단하고 비용이드는것도 아니기에 사용하지 않을 이유가 없다. 그리고 어쨋든
다른사람 으로부터 문의를 하기 위해 가져왔던 브랜치에서는 작업을 하면 안된다.
공개적으로 접근가능한 브랜치를 만들때는 각별히 주의 해야한다.  ##작업이
완료되어 반영할 준비가된 개발 브랜치에서 반영되는것들을 주의 해야한다.

Git provides some powerful tools which can allow you to rewrite your
development history.  An inconvenient patch (one which breaks bisection,
say, or which has some other sort of obvious bug) can be fixed in place or
made to disappear from the history entirely.  A patch series can be
rewritten as if it had been written on top of today's mainline, even though
you have been working on it for months.  Changes can be transparently
shifted from one branch to another.  And so on.  Judicious use of git's
ability to revise history can help in the creation of clean patch sets with
fewer problems.
git은 git 히스토리를 수정할 수 있는 강력한 기능을 제공 한다. 이등분이 안되어
있거나, 확실한 버그가 존재하는 등의 패치는 수정되거나 git 히스토리에서 제거될
수 있다.  패치는 재 수정될 수 있다 심지어 몇달 전에 작성한 패치일 지라도, 마치
메인라인의 최근 가장 위에 작성된 것 처럼 보일것이다. ##수정사항은 투명하게 한
브랜치에서 다른 브랜치로 이동될 수 있다.  git의 히스토리를 개정 기능을 현명하게
사용한 다면, 별 문제 없이 깨긋한 패치를 만드는데 도움이 될 수 있다.

Excessive use of this capability can lead to other problems, though, beyond
a simple obsession for the creation of the perfect project history.
Rewriting history will rewrite the changes contained in that history,
turning a tested (hopefully) kernel tree into an untested one.  But, beyond
that, developers cannot easily collaborate if they do not have a shared
view of the project history; if you rewrite history which other developers
have pulled into their repositories, you will make life much more difficult
for those developers.  So a simple rule of thumb applies here: history
which has been exported to others should generally be seen as immutable
thereafter.
완벽한 히스토리를 만드려고하는 강박관념으로 과도하게 이 기능을 사용하게 되면 또
다른 문제가 발생 할 수 있다. ##히스토리를 수정하면 전체 히스토리내의 수정사항을
수정하게 될 것이며, ##테스트가 완료된 커널트리를 아직 테스트가 되지않은 트리로
만들게 될 것이다.  ##그러나 그것을 넘어서 공유된 프로젝트 히스토리 시각이
없으면 쉽게 협업하기 어려울 수 있다. ##만약 그들의 저장소에 적용한 히스토리를
당신이 수정하면 문제는 보다 심각해 진다. 그래서 간단한 룰이 있다.  ##다른사람
에게 전달된 히스토리는 일반적으로 변경할 수 없다.

So, once you push a set of changes to your publicly-available server, those
changes should not be rewritten.  Git will attempt to enforce this rule if
you try to push changes which do not result in a fast-forward merge
(i.e. changes which do not share the same history).  It is possible to
override this check, and there may be times when it is necessary to rewrite
an exported tree.  Moving changesets between trees to avoid conflicts in
linux-next is one example.  But such actions should be rare.  This is one
of the reasons why development should be done in private branches (which
can be rewritten if necessary) and only moved into public branches when
it's in a reasonably advanced state.
그래서 당신의 공개접근이 허용된 서버에 한번 수정사항을 반영했다면 그 뒤에
수정을 하면 안된다.  만약 fast-forward merge의 결과가 아닌(다시말해, 같은
히스토리를 공유하지 않는) 수정사항이라면, git은 이런 규칙을 강제할것이다.
이것을 체크하는것을 무효시킬수도 있다. ##export된 트리의 수정이 필요할때 수정할
수 있는 기간이 있을 것이다. 한 예로 linux-next에서 트리 사이에서 충돌을
방지하기위해 수정사항을 옮기기도 한다. 그러나 이런 일은 거의 드물다.  이것이
개발자들이 필요할 때 언제든지 수정할 수 있는 본인의 브랜치에서 작업을 해야하는
이유이다. 그리고 ##합리적으로 개선된 상태일때만 공개 브랜치로 옮겨야 한다.

##As the mainline (or other tree upon which a set of changes is based)
advances, it is tempting to merge with that tree to stay on the leading
edge.  For a private branch, rebasing can be an easy way to keep up with
another tree, but rebasing is not an option once a tree is exported to the
world.  Once that happens, a full merge must be done.  Merging occasionally
makes good sense, but overly frequent merges can clutter the history
needlessly.  Suggested technique in this case is to merge infrequently, and
generally only at specific release points (such as a mainline -rc
release).  If you are nervous about specific changes, you can always
perform test merges in a private branch.  The git "rerere" tool can be
useful in such situations; it remembers how merge conflicts were resolved
so that you don't have to do the same work twice.
##메인라인의 발전으로(또는 수정사항의 기준이 되는 다른 트리), 지도적인 위치를
유지하기 위해 반영되는것이 시도된다.  개인 브랜치를 위해서, rebase하는것은 다른
트리를 유지하는 가장 쉬운 방법이다.  그러나 rebase는 한번 트리가 export되면
더이상 선택할 수 있는 옵션이 아니다.  그렇게 되면 full merge가 되어야 한다.
자주 merge하는 것은 바람직하다. 그러나 지나치게 자주 merge를 하면 히스토리에
불필요한 혼란을 가져오게 된다.  이런 경우 드물게 merge하기 위해 다음의 스킬을
제안한다. 메인라인 -rc 릴리즈 같이 특정 릴리즈 지점에서만 반영하는것이다. 만약
당신이 특정 수정사항들에 민감하다면 개인 브랜치에서 항상 테스트 가능하다.
git의 "rerere" 툴은 이런 상황에서 유용하다. 이것을 이용하면 merge 충돌이 나서
해결한 사항을 기억하고 있어서 다음번에 똑같은 작업을 또 할 필요하 없다.

One of the biggest recurring complaints about tools like git is this: the
mass movement of patches from one repository to another makes it easy to
slip in ill-advised changes which go into the mainline below the review
radar.  Kernel developers tend to get unhappy when they see that kind of
thing happening; putting up a git tree with unreviewed or off-topic patches
can affect your ability to get trees pulled in the future.  Quoting Linus:
git에대해 끊임없이 발생하는 불만은 다음과 같다.  ##review radar 하에 메인라인에
반영하려는 패치를 주의깊게 만들지 않으면, 방대한 양의 패치가 한 저장소에서 다른
저장소로 이동할때 문제가 발생하기 쉽다. 커널 개발자들은 이런상황을 마주칠때
불편을 느낀다.  리뷰를 받지않거나 주제에서 벗어난 패치를 git 트리에 올리는것은
나중에 tree를 pull 할때 불이익을 받을 수 있다. 리누스 토발즈는 이에 대해 다음과
같이 말했다.

	You can send me patches, but for me to pull a git patch from you, I
	need to know that you know what you're doing, and I need to be able
	to trust things *without* then having to go and check every
	individual change by hand.
	당신의 git 패치를 나에게 pull함으로써, 당신은 나에게 패치를 보낼 수
	있습니다.  그리고 바라건데, 당신이 무슨작업을 했는지는 알기 원합니다.
	그리고 제가 일일이 수정사항을 체크하지 않고도 당신의 패치를 신뢰할 수
	있었으면 좋겠습니다.

(http://lwn.net/Articles/224135/).

To avoid this kind of situation, ensure that all patches within a given
branch stick closely to the associated topic; a "driver fixes" branch
should not be making changes to the core memory management code.  And, most
importantly, do not use a git tree to bypass the review process.  Post an
occasional summary of the tree to the relevant list, and, when the time is
right, request that the tree be included in linux-next.
이런 상황을 피하기 위해서 주제와 밀접한 관계가 있는 브랜치의 패치인지 확실히
하라.  예를 들어 "driver fixes" 브랜치에서는 core memory management 코드를
수정하면 안된다.  그리고 가장 중요한것은 git 트리를 리뷰 과정을 피하기위해
사용하면 안된다는 것이다.  때때로 트리에 요약내용을 정리해서 올리면 좋다.
그러면 모든것이 바람직할 때, ##그 트리의 요청은 linux-next에 반영될 것이다.

If and when others start to send patches for inclusion into your tree,
don't forget to review them.  Also ensure that you maintain the correct
authorship information; the git "am" tool does its best in this regard, but
you may have to add a "From:" line to the patch if it has been relayed to
you via a third party.
만약 다른 사람의 패치를 당신의 트리로 포함 시키고하 한다면 그 패치를
리뷰하는것을 잊지마라.  그리고 ##그리고 올바른 저작정보가 있는지 확실히 하라.
git "am"툴은 이기능을 이용하는데에 가장 좋은 옵션이다.  ##그러나 third party를
통해 이어진 패치라면 당신은 "From:"을 추가해야한다.

When requesting a pull, be sure to give all the relevant information: where
your tree is, what branch to pull, and what changes will result from the
pull.  The git request-pull command can be helpful in this regard; it will
format the request as other developers expect, and will also check to be
sure that you have remembered to push those changes to the public server.
pull request를 할때, 모든 관련 정보를 확실히 하라. 당신의 트리는 어디있는지,
어떤 브랜치를 pull하려고 하는지, pull을 통해 어떤 결과가 나타날 수 있는지.
##git request-pull 명령어는 이것에 도움이 될 것이다.  이 명령어는 다른
개발자들이 기대하는 포맷에 맞출 것이다. ##그리고 이 수정사항을 공개 서버로
push하는지 기억하도록 해줄 것이다.


7.2: REVIEWING PATCHES

Some readers will certainly object to putting this section with "advanced
topics" on the grounds that even beginning kernel developers should be
reviewing patches.  It is certainly true that there is no better way to
learn how to program in the kernel environment than by looking at code
posted by others.  In addition, reviewers are forever in short supply; by
looking at code you can make a significant contribution to the process as a
whole.

Reviewing code can be an intimidating prospect, especially for a new kernel
developer who may well feel nervous about questioning code - in public -
which has been posted by those with more experience.  Even code written by
the most experienced developers can be improved, though.  Perhaps the best
piece of advice for reviewers (all reviewers) is this: phrase review
comments as questions rather than criticisms.  Asking "how does the lock
get released in this path?" will always work better than stating "the
locking here is wrong."

Different developers will review code from different points of view.  Some
are mostly concerned with coding style and whether code lines have trailing
white space.  Others will focus primarily on whether the change implemented
by the patch as a whole is a good thing for the kernel or not.  Yet others
will check for problematic locking, excessive stack usage, possible
security issues, duplication of code found elsewhere, adequate
documentation, adverse effects on performance, user-space ABI changes, etc.
All types of review, if they lead to better code going into the kernel, are
welcome and worthwhile.


