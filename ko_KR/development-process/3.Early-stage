3: 초기 단계 계획하기

리눅스 커널 개발 프로젝트에 참여하고자 할 때, 팔을 걷어 부치고 바로 코딩 부터
하고싶어 질 수 있다.  ##하지만 여타 주요 프로젝트들과 마찬가지로 첫 번째 코드
행이 작성되기 전에 성공적인 기초작업 대부분은 이미 완료되어 있다.  초기 계획과
의사소통에 소요 된 시간을 통해 나중에 훨씬 더 많은 시간을 절약 할 수 있다.


3.1: 문제 명시하기

여타 엔지니어링 프로젝트들과 마찬가지로, 성공적으로 커널 개선을 하기 위해서는
해결할 문제를 명확하게 기술 해야 한다.  몇몇 경우, 이 단계는 매우 간단하다.
드라이버가 특정 하드웨어를 위해 필요한 경우가 한 예이다. ##하지만 대부분의 경우
제안된 해결방법과 실제 문제를 혼동하기 쉽고 그것이 문제를 일으키기도 한다.

예를 살펴보면, 몇년전 리눅스 오디오 작업을 하던 개발자들이 시스템에 과도한
대기시간으로 인한 영향이나 손실 없이 응용 프로그램을 실행할 수 있는 방법을
모색하고 있었다.  그들이 결론낸 솔루션은 리눅스 보안 모듈(LSM) 프레임워크에
Hooking 하기위한 커널 모듈이었다.  이 모듈은 특정 응용프로그램이 실시간
스케줄러에 대한 액세스 권한을 부여하도록 구성될 수 있다.  이 모듈은 구현되어
즉시 linux-kernel 메일링리스트로 보내져 문제에 바로 적용 되었다.

오디오 개발자들에게 이 보안 모듈은 즉시 문제를 해결하기에 충분했다.  그러나
커널 커뮤니티에게 그것은 LSM 프레임워크의 오용(프로세스에 계획되지 않은 권한을
부여) 혹은 시스템 안정성에 위험으로 간주되었다.  커뮤니티가 선호한 솔루션은
단기적으로 rlimit 메커니즘을 통해 실시간 스케줄링에 액세스하고 장기적으로는
지속적인 대기시간의 감소 작업을 하는 것이었다.

그러나 오디오 커뮤니티는 그들이 구현 한 솔루션 외에 대안을 생각 할 수 없었다.
그들은 대안을 수용하지 않으려했고 커널 커뮤니티와 불일치로 전체 커널 개발
프로세스에 환멸을 느끼게 됐다.  오디오 개발자들 중 하나는 오디오 리스트로 가서
다음 글을 게시했다

	좋은 리눅스 커널 개발자가 많이 있지만, 그들은 목소리만 큰 오만하고
	멍청한 무리가 내는 의견을 받아드리는 경향이 있다.  그들에게 사용자
	요구사항에 대해 대화를 시도하는 것은 시간 낭비이다.  어쭙잖은 인간들의
	이야기를 듣기엔 그들은 너무나 뛰어나다.

(http://lwn.net/Articles/131776/).

실제 상황은 달랐다.  커널 개발자들은 특정 모듈에 대한 문제로 본것이 아니라
시스템 안정성, 장기간 유지보수성, 정확한 솔루션을 고려한 것이다.  이 이야기의
교훈은 특정 솔루션에 메달릴 것이 아니라 문제에 집중하고 코딩을 시작하기 전에
커뮤니티와 충분히 논의해야 한다는 것이다.

따라서 커널 개발 프로젝트를 생각하는 개발자는 다음 질문들에 대한 답을
얻어야한다.

 - 정확히 어떤 문제가 해결되야 하는가?

 - 이 문제에 영향을 받는 사용자들은 누구인가? 솔루션은 어떤 유스 케이스를
   다뤄야 하는가?

 - 커널이 현재 그 문제를 다루는데 어떻게 부족한가?

위 질문에 답을 얻은 후에야 가능한 솔루션들을 생각해 볼 수 있다.


3.2: 초기 단계 논의

커널 개발을 계획할 때, 코드를 반영 하기 전에 먼저 커뮤니티와 충분히 논의를 하는
것이 바람직하다.  이런 의사소통은 여러가지로 시간과 문제를 줄여줄 수 있다.

 - 커널이 문제를 해결한 방법을 당신이 이해하지 못하는 것은 당연하다.  리눅스
   커널은 너무 크고 즉시 눈에 띄지 않는 수 많은 특징과 기능이 있다.  특정 한
   사람을 만족시킬 정도로 커널 모든 기능이 문서화 되어 있는 것도 아니다.
   문서화 하는것을 잊어버리기도 쉽다.  ##메인테이너는 새로운 작성자를 통해 이미
   드라이버가 존재하는데도 똑같은 드라이버를 새로짠 패치가 포스팅 되오던것을
   봐왔다.  그들은 그것이 중복 되었다는것을 자각하지도 못했다.  이미 존재하는
   코드를 다시 작성하는 것은 쓸모없을 뿐더러 메인라인 커널에서 받아드려지지
   못할 것이다.

 - 메인 라인에 반영되지 못할 솔루션으로 제안되는 것들이 있을 것이다.
   그럴바에는 차라리 코드를 작성하기 전에 그런 문제를 찾는것이 더 낫다.

 - 다른 개발자들은 분명히 해결할 수 있는 더 좋은 아이디어를 가지고 있을 것이고
   이런 해결책을 구현하는데에 기꺼히 도우려고 것이다.

다년간의 커뮤니티에서의 커널 개발 경험을 통해 다음의 교훈을 얻게 되었다.
비공개로 비밀리에 작업하거나 설계한 코드는 커뮤니티에서 릴리즈 될때 반드시
문제가 된다.  때로는 문제는 심각해지기도 하며, 커뮤니티의 표준으로 반영되기
까지 몇달 혹은 몇년의 노력이 필요하다.  예를 들면 다음과 같다.

 - Devicescape network stack 은 싱글 코어 프로세서 기반으로 설계되었다.  따라서
   멀티 프로세서를 지원하지 않는 이상 메인라인에 반영될 수 없었다.  이 코드를
   개선하는 것은 매우 어려운 작업이었기 때문에, 이 코드가 반영되기 까지 1년
   이상 지연되었다.

 - Reiser4 파일 시스템은 많은 장점을 가지고 있었다.  핵심 커널 개발자의 의견에
   따르면 이 파일 시스템이 가상 파일 시스템 레이어를 지원하야 한다고 했다.
   그러나 이것도 시스템에 user-caused deadlock 없이 쉽게 구현되기 어려운 특징을
   지녔기 때문에 지연의 문제가 발생하였다.  그리고 결국 메인라인 커널에서
   지원하지 않게 되었다.

 - AppArmor 시큐리티 모듈은 안전하지 못하고 불확실하게 결정된 방법으로
   내부적으로 가상 파일시스템 자료구조의 필요성을 만들었다. 이런 우려 때문에
   때문에 수년 째 메인라인 커널에서 제거된 상태이다.

이런 여러가지 경우를 봤을때 많은 어려움이나 특별한 작업을 다루는 일은
커뮤니티의 논의를 통해 조기에 피하는 것이 좋다.


3.3: 누구와 논의 하나?

개발자가 그들의 계획을 공개적으로 수행하고자 한다면, 다음 질문은 이것이 될
것이다.  어디서 작업을 해야하는가?  그에 대한 답변은 올바른 메일링 리스트와
메인테이너를 찾는 것이 될것이다.  메일링리스트를 찾을 때 가장 적절한 방법은
MAINTAINERS 파일에서 올리고자 하는 내용과 연관된 메일링 리스트를 찾는 것이다.
적절한 서브 시스템 리스트를 찾았다면 그곳에 올리는게 linux-kernel메일링
리스트에 올리는 것보다 더 바람직하다.  더욱 직접적으로 연관 되어있는 개발자들과
만날 수 있으며 지원을 더 잘 받을 수 있는 환경일 가능성이 크다.

메인테이너를 찾는것은 좀더 어려울 수 있다.  마찬가지로 MAINTAINERS 파일이 시작
지점이다.  그러나 이 파일은 항상 최신 상태를 유지하지 않는 경향이 있다.  게다가
모든 서브시스템을 다 포함하는 것도 아니다.  또한 MAINTAINERS 파일에 있는 사람이
현재 실제 그 역할을 하지 않을 수도 있다.  그래서 누굴 컨택 해야할지 확실 하지
않을 때 좋은 방법은 git을(더 정확히는 git log) 이용 하는 것이다.  git log를
통해 해당 서브시스템에서 현재 활동하고 있는 메인테이너를 찾을 수 있을 것이다.
누가 패치를 작성했는지 누가 패치를 승인 했는지 확인 하라.  이 사람들이
프로젝트를 진행할 때 도움이 될 수 있는 가장 적절한 사람들이다.

적절한 메인테이너를 찾는 것이 충분하지 않아, 쉽게 찾기 위해 커널 개발자들이
아래와 같은 스크립트를 추가하였다.

	.../scripts/get_maintainer.pl

이 스크립트는 -f 옵션으로 파일 및 경로를 전달하면 현재 메인테이너를 알려줄
것이다.  만약 커맨드 라인에서 패치를 찾았다면 거기에 패치를 누가 받아야하는지
알 수 있는 메인테이너 리스트가 있을 것이다.  메인테이너를 찾는 것이 얼마나
어려운지 get_maintainer.pl에는 상당히 많은 옵션이 있다.  결국 당신이 작성한
코드에 아무 관심도 없는 메인테이너를 찾지 않도록 옵션을 주의 해서 사용하라.

이렇게 해도 실패 했다면 Andrew Morton과 연락하는것이 적절한 메인테이너를 찾는
효과적인 방법이 될 수 있다.


3.4: 언제 포스팅을 해야하는가?

가능 하다면, 초기 단계일때 계획을 올리는것만이 도움이 될것이다.  해결하려고
하는 문제와 구현이 언제 완료될 것이라는 계획을 기술 해라.  제공할수 있는대로
많은 정보를 알려주는것이 커뮤니티를 통해 프로젝트에 유용한 도움을 받을 수 있는
지름길이다.

이 단계에서 실망하게 될 수 있는 것은 적대적인 반응이 아니다.  거의 반응이
없거나 반응이 아얘 없는 것이다.  슬픈 사실은 (1)커널 개발자들은 꽤 바쁘다는것
(2)##원대한 계획을 가지고 있는 개발자들이 적지 않다는것.  그리고 그들을
지원하기 위한 코드가 있다는것.  (3)누구도 아이디어에 대해서 리뷰나 답변을 해줄
의무는 없다는 점.  ##이런 것들을 떠나서 지나치게 높은 수준의 계획에는 종종
누군가가 실제로 그것을 개발 할때만 발견되는 문제가 발생하기도 한다.  이러한
이유 때문에 커널 개발자는 차라리 코드로 구현된 것을 더 선호한다.

답변요청을 올리는것은 답변이 달리는데에 방해가 될 뿐이다.  프로젝트에 관심이
없다는 뜻으로 추측하지 말아야 한다.  유감스럽게도 본인의 아이디어가 아무런
문제가 없다고 판단할 수 없을 것이다.  이런 상황에서 가장 좋은 방법은 계속 진행
하는 것이다.  지속적으로 커뮤니티의 정보를 파악하라.


3.5: 공식적으로 참여하기.

회사에서 작업하는 것이라면 (대부분 리눅스 커널 작업이 그렇듯이) 회사의 계획이나
코드를 메일링 리스트에 올리기 전에 반드시 회사에서 해당 매니져에게 허가를
받아야한다.  특히 GPL계열의 라이센스 하에 작성되지 않은 코드를 올리는 것은
문제가 있다.  회사의 관리자나 법률 팀이 이 커널 개발 프로젝트에 대해서 포스팅
하는것에 동의 할수 있다.  관련된 모든 사람들이 더 잘 알 것이다.

##몇몇 독자는 이시점에서 그들의 커널 작업이 공식적으로 인정되지 않는 제품을
지원하기 위한 의도가 아니냐는 생각을 가질 수도 있다.  회사의 계획을 공개적인
메일링 리스트에 드러내는것은 실행 가능한 방법이 아닐 것이다.  이런 경우에는
이렇게 비밀을 유지하는것이 진정 필요한지에 대해서 고민해보는 것이 좋다.  개발
계획을 비공개적으로 유지하는것은 대부분의 경우 필요하지 않다.

그건 그렇다 치고, 개발 초기 단계에서 합법적으로 공개할 수없는 경우도 존재한다.
노련한 커널 개발자를 가지고 있는 회사는 나중에 생길 수 있는 심각한 integration
문제를 피할 수 있다는 가정 하에 open-loop 규정으로 진행 하는것을 선택할 것이다.
사내에 전문기술이 없는 회사에 있어서는, 비공개 계획에 따라 리뷰를 하기 위한
외부 개발자를 고용하는 방법이 있을 것이다.  Linux Foundation에서는 이러한
상황을 위해 NDA 프로그램을 운영한다.  아래 주소 참고.

    http://www.linuxfoundation.org/en/NDA_program

이런 리뷰는 이후의 프로젝트의 공개 요청이 없을때 발생할 수 있는 문제들을
피하는데 도움이 될 것이다.
